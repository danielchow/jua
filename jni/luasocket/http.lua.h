{
static const char* F =
"-----------------------------------------------------------------------------    \n"
"-- HTTP/1.1 client support for the Lua language.                                 \n"
"-- LuaSocket toolkit.                                                            \n"
"-- Author: Diego Nehab                                                           \n"
"-----------------------------------------------------------------------------    \n"
"                                                                                 \n"
"-----------------------------------------------------------------------------    \n"
"-- Declare module and import dependencies                                        \n"
"-------------------------------------------------------------------------------  \n"
"local socket = require('socket')                                                 \n"
"local url = require('socket.url')                                                \n"
"local ltn12 = require('ltn12')                                                   \n"
"local mime = require('mime')                                                     \n"
"local string = require('string')                                                 \n"
"local headers = require('socket.headers')                                        \n"
"local base = _G                                                                  \n"
"local table = require('table')                                                   \n"
"socket.http = {}                                                                 \n"
"local _M = socket.http                                                           \n"
"                                                                                 \n"
"-----------------------------------------------------------------------------    \n"
"-- Program constants                                                             \n"
"-----------------------------------------------------------------------------    \n"
"-- connection timeout in seconds                                                 \n"
"_M.TIMEOUT = 60                                                                  \n"
"-- default port for document retrieval                                           \n"
"_M.PORT = 80                                                                     \n"
"-- user agent field sent in request                                              \n"
"_M.USERAGENT = socket._VERSION                                                   \n"
"                                                                                 \n"
"-----------------------------------------------------------------------------    \n"
"-- Reads MIME headers from a connection, unfolding where needed                  \n"
"-----------------------------------------------------------------------------    \n"
"local function receiveheaders(sock, headers)                                     \n"
"    local line, name, value, err                                                 \n"
"    headers = headers or {}                                                      \n"
"    -- get first line                                                            \n"
"    line, err = sock:receive()                                                   \n"
"    if err then return nil, err end                                              \n"
"    -- headers go until a blank line is found                                    \n"
"    while line ~= '' do                                                          \n"
"        -- get field-name and value                                              \n"
"        name, value = socket.skip(2, string.find(line, '^(.-):%s*(.*)'))         \n"
"        if not (name and value) then return nil, 'malformed reponse headers' end \n"
"        name = string.lower(name)                                                \n"
"        -- get next line (value might be folded)                                 \n"
"        line, err  = sock:receive()                                              \n"
"        if err then return nil, err end                                          \n"
"        -- unfold any folded values                                              \n"
"        while string.find(line, '^%s') do                                        \n"
"            value = value .. line                                                \n"
"            line = sock:receive()                                                \n"
"            if err then return nil, err end                                      \n"
"        end                                                                      \n"
"        -- save pair in table                                                    \n"
"        if headers[name] then headers[name] = headers[name] .. ', ' .. value     \n"
"        else headers[name] = value end                                           \n"
"    end                                                                          \n"
"    return headers                                                               \n"
"end                                                                              \n"
"                                                                                 \n"
"-----------------------------------------------------------------------------    \n"
"-- Extra sources and sinks                                                       \n"
"-----------------------------------------------------------------------------    \n"
"socket.sourcet['http-chunked'] = function(sock, headers)                         \n"
"    return base.setmetatable({                                                   \n"
"        getfd = function() return sock:getfd() end,                              \n"
"        dirty = function() return sock:dirty() end                               \n"
"    }, {                                                                         \n"
"        __call = function()                                                      \n"
"            -- get chunk size, skip extention                                    \n"
"            local line, err = sock:receive()                                     \n"
"            if err then return nil, err end                                      \n"
"            local size = base.tonumber(string.gsub(line, ';.*', ''), 16)         \n"
"            if not size then return nil, 'invalid chunk size' end                \n"
"            -- was it the last chunk?                                            \n"
"            if size > 0 then                                                     \n"
"                -- if not, get chunk and skip terminating CRLF                   \n"
"                local chunk, err, part = sock:receive(size)                      \n"
"                if chunk then sock:receive() end                                 \n"
"                return chunk, err                                                \n"
"            else                                                                 \n"
"                -- if it was, read trailers into headers table                   \n"
"                headers, err = receiveheaders(sock, headers)                     \n"
"                if not headers then return nil, err end                          \n"
"            end                                                                  \n"
"        end                                                                      \n"
"    })                                                                           \n"
"end                                                                              \n"
"                                                                                 \n"
"socket.sinkt['http-chunked'] = function(sock)                                    \n"
"    return base.setmetatable({                                                   \n"
"        getfd = function() return sock:getfd() end,                              \n"
"        dirty = function() return sock:dirty() end                               \n"
"    }, {                                                                         \n"
"        __call = function(self, chunk, err)                                      \n"
"            if not chunk then return sock:send('0\r\n\r\n') end                  \n"
"            local size = string.format('%X\r\n', string.len(chunk))              \n"
"            return sock:send(size ..  chunk .. '\r\n')                           \n"
"        end                                                                      \n"
"    })                                                                           \n"
"end                                                                              \n"
"                                                                                 \n"
"-----------------------------------------------------------------------------    \n"
"-- Low level HTTP API                                                            \n"
"-----------------------------------------------------------------------------    \n"
"local metat = { __index = {} }                                                   \n"
"                                                                                 \n"
"function _M.open(host, port, create)                                             \n"
"    -- create socket with user connect function, or with default                 \n"
"    local c = socket.try((create or socket.tcp)())                               \n"
"    local h = base.setmetatable({ c = c }, metat)                                \n"
"    -- create finalized try                                                      \n"
"    h.try = socket.newtry(function() h:close() end)                              \n"
"    -- set timeout before connecting                                             \n"
"    h.try(c:settimeout(_M.TIMEOUT))                                              \n"
"    h.try(c:connect(host, port or _M.PORT))                                      \n"
"    -- here everything worked                                                    \n"
"    return h                                                                     \n"
"end                                                                              \n"
"                                                                                 \n"
"function metat.__index:sendrequestline(method, uri)                              \n"
"    local reqline = string.format('%s %s HTTP/1.1\r\n', method or 'GET', uri)    \n"
"    return self.try(self.c:send(reqline))                                        \n"
"end                                                                              \n"
"                                                                                 \n"
"function metat.__index:sendheaders(tosend)                                       \n"
"    local canonic = headers.canonic                                              \n"
"    local h = '\r\n'                                                             \n"
"    for f, v in base.pairs(tosend) do                                            \n"
"        h = (canonic[f] or f) .. ': ' .. v .. '\r\n' .. h                        \n"
"    end                                                                          \n"
"    self.try(self.c:send(h))                                                     \n"
"    return 1                                                                     \n"
"end                                                                              \n"
"                                                                                 \n"
"function metat.__index:sendbody(headers, source, step)                           \n"
"    source = source or ltn12.source.empty()                                      \n"
"    step = step or ltn12.pump.step                                               \n"
"    -- if we don't know the size in advance, send chunked and hope for the best  \n"
"    local mode = 'http-chunked'                                                  \n"
"    if headers['content-length'] then mode = 'keep-open' end                     \n"
"    return self.try(ltn12.pump.all(source, socket.sink(mode, self.c), step))     \n"
"end                                                                              \n"
"                                                                                 \n"
"function metat.__index:receivestatusline()                                       \n"
"    local status = self.try(self.c:receive(5))                                   \n"
"    -- identify HTTP/0.9 responses, which do not contain a status line           \n"
"    -- this is just a heuristic, but is what the RFC recommends                  \n"
"    if status ~= 'HTTP/' then return nil, status end                             \n"
"    -- otherwise proceed reading a status line                                   \n"
"    status = self.try(self.c:receive('*l', status))                              \n"
"    local code = socket.skip(2, string.find(status, 'HTTP/%d*%.%d* (%d%d%d)'))   \n"
"    return self.try(base.tonumber(code), status)                                 \n"
"end                                                                              \n"
"                                                                                 \n"
"function metat.__index:receiveheaders()                                          \n"
"    return self.try(receiveheaders(self.c))                                      \n"
"end                                                                              \n"
"                                                                                 \n"
"function metat.__index:receivebody(headers, sink, step)                          \n"
"    sink = sink or ltn12.sink.null()                                             \n"
"    step = step or ltn12.pump.step                                               \n"
"    local length = base.tonumber(headers['content-length'])                      \n"
"    local t = headers['transfer-encoding'] -- shortcut                           \n"
"    local mode = 'default' -- connection close                                   \n"
"    if t and t ~= 'identity' then mode = 'http-chunked'                          \n"
"    elseif base.tonumber(headers['content-length']) then mode = 'by-length' end  \n"
"    return self.try(ltn12.pump.all(socket.source(mode, self.c, length),          \n"
"        sink, step))                                                             \n"
"end                                                                              \n"
"                                                                                 \n"
"function metat.__index:receive09body(status, sink, step)                         \n"
"    local source = ltn12.source.rewind(socket.source('until-closed', self.c))    \n"
"    source(status)                                                               \n"
"    return self.try(ltn12.pump.all(source, sink, step))                          \n"
"end                                                                              \n"
"                                                                                 \n"
"function metat.__index:close()                                                   \n"
"    return self.c:close()                                                        \n"
"end                                                                              \n"
"                                                                                 \n"
"-----------------------------------------------------------------------------    \n"
"-- High level HTTP API                                                           \n"
"-----------------------------------------------------------------------------    \n"
"local function adjusturi(reqt)                                                   \n"
"    local u = reqt                                                               \n"
"    -- if there is a proxy, we need the full url. otherwise, just a part.        \n"
"    if not reqt.proxy and not _M.PROXY then                                      \n"
"        u = {                                                                    \n"
"           path = socket.try(reqt.path, 'invalid path 'nil''),                   \n"
"           params = reqt.params,                                                 \n"
"           query = reqt.query,                                                   \n"
"           fragment = reqt.fragment                                              \n"
"        }                                                                        \n"
"    end                                                                          \n"
"    return url.build(u)                                                          \n"
"end                                                                              \n"
"                                                                                 \n"
"local function adjustproxy(reqt)                                                 \n"
"    local proxy = reqt.proxy or _M.PROXY                                         \n"
"    if proxy then                                                                \n"
"        proxy = url.parse(proxy)                                                 \n"
"        return proxy.host, proxy.port or 3128                                    \n"
"    else                                                                         \n"
"        return reqt.host, reqt.port                                              \n"
"    end                                                                          \n"
"end                                                                              \n"
"                                                                                 \n"
"local function adjustheaders(reqt)                                               \n"
"    -- default headers                                                           \n"
"    local host = string.gsub(reqt.authority, '^.-@', '')                         \n"
"    local lower = {                                                              \n"
"        ['user-agent'] = _M.USERAGENT,                                           \n"
"        ['host'] = host,                                                         \n"
"        ['connection'] = 'close, TE',                                            \n"
"        ['te'] = 'trailers'                                                      \n"
"    }                                                                            \n"
"    -- if we have authentication information, pass it along                      \n"
"    if reqt.user and reqt.password then                                          \n"
"        lower['authorization'] =                                                 \n"
"            'Basic ' ..  (mime.b64(reqt.user .. ':' .. reqt.password))           \n"
"    end                                                                          \n"
"    -- override with user headers                                                \n"
"    for i,v in base.pairs(reqt.headers or lower) do                              \n"
"        lower[string.lower(i)] = v                                               \n"
"    end                                                                          \n"
"    return lower                                                                 \n"
"end                                                                              \n"
"                                                                                 \n"
"-- default url parts                                                             \n"
"local default = {                                                                \n"
"    host = '',                                                                   \n"
"    port = _M.PORT,                                                              \n"
"    path ='/',                                                                   \n"
"    scheme = 'http'                                                              \n"
"}                                                                                \n"
"                                                                                 \n"
"local function adjustrequest(reqt)                                               \n"
"    -- parse url if provided                                                     \n"
"    local nreqt = reqt.url and url.parse(reqt.url, default) or {}                \n"
"    -- explicit components override url                                          \n"
"    for i,v in base.pairs(reqt) do nreqt[i] = v end                              \n"
"    if nreqt.port == '' then nreqt.port = 80 end                                 \n"
"    socket.try(nreqt.host and nreqt.host ~= '',                                  \n"
"        'invalid host '' .. base.tostring(nreqt.host) .. ''')                    \n"
"    -- compute uri if user hasn't overriden                                      \n"
"    nreqt.uri = reqt.uri or adjusturi(nreqt)                                     \n"
"    -- ajust host and port if there is a proxy                                   \n"
"    nreqt.host, nreqt.port = adjustproxy(nreqt)                                  \n"
"    -- adjust headers in request                                                 \n"
"    nreqt.headers = adjustheaders(nreqt)                                         \n"
"    return nreqt                                                                 \n"
"end                                                                              \n"
"                                                                                 \n"
"local function shouldredirect(reqt, code, headers)                               \n"
"    return headers.location and                                                  \n"
"           string.gsub(headers.location, '%s', '') ~= '' and                     \n"
"           (reqt.redirect ~= false) and                                          \n"
"           (code == 301 or code == 302 or code == 303 or code == 307) and        \n"
"           (not reqt.method or reqt.method == 'GET' or reqt.method == 'HEAD')    \n"
"           and (not reqt.nredirects or reqt.nredirects < 5)                      \n"
"end                                                                              \n"
"                                                                                 \n"
"local function shouldreceivebody(reqt, code)                                     \n"
"    if reqt.method == 'HEAD' then return nil end                                 \n"
"    if code == 204 or code == 304 then return nil end                            \n"
"    if code >= 100 and code < 200 then return nil end                            \n"
"    return 1                                                                     \n"
"end                                                                              \n"
"                                                                                 \n"
"-- forward declarations                                                          \n"
"local trequest, tredirect                                                        \n"
"                                                                                 \n"
"--[[local]] function tredirect(reqt, location)                                   \n"
"    local result, code, headers, status = trequest {                             \n"
"        -- the RFC says the redirect URL has to be absolute, but some            \n"
"        -- servers do not respect that                                           \n"
"        url = url.absolute(reqt.url, location),                                  \n"
"        source = reqt.source,                                                    \n"
"        sink = reqt.sink,                                                        \n"
"        headers = reqt.headers,                                                  \n"
"        proxy = reqt.proxy,                                                      \n"
"        nredirects = (reqt.nredirects or 0) + 1,                                 \n"
"        create = reqt.create                                                     \n"
"    }                                                                            \n"
"    -- pass location header back as a hint we redirected                         \n"
"    headers = headers or {}                                                      \n"
"    headers.location = headers.location or location                              \n"
"    return result, code, headers, status                                         \n"
"end                                                                              \n"
"                                                                                 \n"
"--[[local]] function trequest(reqt)                                              \n"
"    -- we loop until we get what we want, or                                     \n"
"    -- until we are sure there is no way to get it                               \n"
"    local nreqt = adjustrequest(reqt)                                            \n"
"    local h = _M.open(nreqt.host, nreqt.port, nreqt.create)                      \n"
"    -- send request line and headers                                             \n"
"    h:sendrequestline(nreqt.method, nreqt.uri)                                   \n"
"    h:sendheaders(nreqt.headers)                                                 \n"
"    -- if there is a body, send it                                               \n"
"    if nreqt.source then                                                         \n"
"        h:sendbody(nreqt.headers, nreqt.source, nreqt.step)                      \n"
"    end                                                                          \n"
"    local code, status = h:receivestatusline()                                   \n"
"    -- if it is an HTTP/0.9 server, simply get the body and we are done          \n"
"    if not code then                                                             \n"
"        h:receive09body(status, nreqt.sink, nreqt.step)                          \n"
"        return 1, 200                                                            \n"
"    end                                                                          \n"
"    local headers                                                                \n"
"    -- ignore any 100-continue messages                                          \n"
"    while code == 100 do                                                         \n"
"        headers = h:receiveheaders()                                             \n"
"        code, status = h:receivestatusline()                                     \n"
"    end                                                                          \n"
"    headers = h:receiveheaders()                                                 \n"
"    -- at this point we should have a honest reply from the server               \n"
"    -- we can't redirect if we already used the source, so we report the error   \n"
"    if shouldredirect(nreqt, code, headers) and not nreqt.source then            \n"
"        h:close()                                                                \n"
"        return tredirect(reqt, headers.location)                                 \n"
"    end                                                                          \n"
"    -- here we are finally done                                                  \n"
"    if shouldreceivebody(nreqt, code) then                                       \n"
"        h:receivebody(headers, nreqt.sink, nreqt.step)                           \n"
"    end                                                                          \n"
"    h:close()                                                                    \n"
"    return 1, code, headers, status                                              \n"
"end                                                                              \n"
"                                                                                 \n"
"local function srequest(u, b)                                                    \n"
"    local t = {}                                                                 \n"
"    local reqt = {                                                               \n"
"        url = u,                                                                 \n"
"        sink = ltn12.sink.table(t)                                               \n"
"    }                                                                            \n"
"    if b then                                                                    \n"
"        reqt.source = ltn12.source.string(b)                                     \n"
"        reqt.headers = {                                                         \n"
"            ['content-length'] = string.len(b),                                  \n"
"            ['content-type'] = 'application/x-www-form-urlencoded'               \n"
"        }                                                                        \n"
"        reqt.method = 'POST'                                                     \n"
"    end                                                                          \n"
"    local code, headers, status = socket.skip(1, trequest(reqt))                 \n"
"    return table.concat(t), code, headers, status                                \n"
"end                                                                              \n"
"                                                                                 \n"
"_M.request = socket.protect(function(reqt, body)                                 \n"
"    if base.type(reqt) == 'string' then return srequest(reqt, body)              \n"
"    else return trequest(reqt) end                                               \n"
"end)                                                                             \n"
"                                                                                 \n"
"return _M";
if (luaL_dostring(L, F)!=0) cout << "Error: http.lua";
else cout << "Fine: http.lua";
}